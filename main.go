package main

import (
	"bytes"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"regexp"

	"github.com/argoproj/argo-cd/v2/pkg/apis/application/v1alpha1"
	"github.com/argoproj/argo-cd/v2/util/helm"
	"github.com/argoproj/argo-cd/v2/util/io/path"
	yamlutil "k8s.io/apimachinery/pkg/util/yaml"
)

func createDir(dirName string) error {
	err := os.MkdirAll(dirName, os.ModePerm)
	if err != nil {
		return fmt.Errorf("error creating directory: %s %s", dirName, err)
	}
	return nil
}

func createTempFile(payload string) (string, error) {
	// create a temp file with the results of a yaml block:
	tmpYamlFile, err := os.CreateTemp("", "temp.*.yaml")
	if err != nil {
		log.Println("Error creating temp file")
		return "", err
	}

	if _, err := tmpYamlFile.Write([]byte(payload)); err != nil {
		return "", err
	}
	if err := tmpYamlFile.Close(); err != nil {
		return "", err
	}

	return tmpYamlFile.Name(), nil
}

func readApplication(fileName string) ([]*v1alpha1.Application, error) {
	crdSpecs := make([]*v1alpha1.Application, 0)
	yamlFile, err := ioutil.ReadFile(fileName)
	if err != nil {
		return crdSpecs, fmt.Errorf("error reading crd: %s %v", fileName, err)
	}
	dec := yamlutil.NewYAMLOrJSONDecoder(bytes.NewReader(yamlFile), 1000)
	for {
		app := v1alpha1.Application{}
		if err := dec.Decode(&app); err != nil {
			if err != io.EOF {
				break
			}
			return crdSpecs, err
		}
		crdSpecs = append(crdSpecs, &app)
	}
	return crdSpecs, nil

}

func unpackParams(params []v1alpha1.HelmParameter) map[string]string {
	paramsMap := make(map[string]string)
	for i := range params {
		paramsMap[params[i].Name] = params[i].Value
	}
	return paramsMap
}

func resolveFiles(payload *v1alpha1.Application) ([]path.ResolvedFilePath, error) {
	// also check for tmp files!!
	filePaths := []path.ResolvedFilePath{}
	allowedRemoteProtocols := []string{"http", "https"}
	files := payload.Spec.Source.Helm.ValueFiles
	matchDots := regexp.MustCompile(`\.\.\/`)
	for i := 0; i < len(files); i++ {
		valueFile := matchDots.ReplaceAllString(files[i], "")
		pth, _, err := path.ResolveFilePath(
			".", // uses current directory for appPath
			".", // uses current directory for repoRoot as we're already there
			valueFile,
			allowedRemoteProtocols,
		)

		if err != nil {
			return nil, err
		}
		filePaths = append(filePaths, pth)
	}

	return filePaths, nil
}

func buildHelmCommand(app *v1alpha1.Application) (string, error) {
	if app.Spec.Source.Helm != nil {
		h, err := helm.NewHelmApp(
			app.Spec.Source.Path,
			[]helm.HelmRepository{{
				Name: app.Spec.Source.Path,
				Repo: app.Spec.Source.RepoURL,
			}},
			true,
			"",
			"",
			false,
		)
		if err != nil {
			fmt.Printf("error creating helm app: %v", err)
		}

		resolvedFiles, ferr := resolveFiles(app)
		if ferr != nil {
			log.Fatal(ferr)
		}

		params := unpackParams(app.Spec.Source.Helm.Parameters)

		if app.Spec.Source.Helm.Values != "" {
			tmpFile, err := createTempFile(app.Spec.Source.Helm.Values)
			defer os.Remove(tmpFile)
			if err != nil {
				fmt.Println(err)
			}

			allowedRemoteProtocols := []string{"http", "https"}
			tmpFilePath, _, err := path.ResolveFilePath(
				"/",
				"/",
				tmpFile,
				allowedRemoteProtocols,
			)
			if err != nil {
				fmt.Println(err)
			}

			resolvedFiles = append(resolvedFiles, tmpFilePath)
		}

		opts := helm.TemplateOpts{
			Name:      app.Name,
			Namespace: app.Spec.Destination.Namespace,
			Set:       params,
			Values:    resolvedFiles,
		}

		manifest, err2 := h.Template(&opts)
		if err2 != nil {
			if !helm.IsMissingDependencyErr(err2) {
				log.Fatal(err2)
			}

			return "", fmt.Errorf("error rendering the manifest: %v", err2)
		}

		return manifest, nil
	}
	return "", fmt.Errorf("no manifest was rendered")
}

func writeToFile(manifest, location string) error {
	if err := createDir(location); err != nil {
		return err
	}
	return ioutil.WriteFile(
		fmt.Sprintf(
			"%s/%s",
			location,
			"manifest.yaml",
		),
		[]byte(manifest),
		0664,
	)
}

func processCrds(crdData []*v1alpha1.Application, output string) {
	for _, crd := range crdData {
		if crd.Kind == "Application" {
			manifest, err := buildHelmCommand(crd)
			if err != nil {
				fmt.Println(err)
			}
			location := fmt.Sprintf("%s/%s", output, crd.Name)
			writeToFile(manifest, location)
			crdData, err := readApplication(fmt.Sprintf("%s/manifest.yaml", location))
			if err != nil {
				if err != io.EOF {
					log.Fatalf("error creating crdData: %v", err)
				}
			}
			processCrds(crdData, output)
		}
	}

}

func main() {
	crdFile := flag.String("crd", "", "application crd file name")
	outputDir := flag.String("output", "zz.autogenerated", "Path to store the compiled Argo Applications")
	flag.Parse()
	if *crdFile == "" {
		log.Println("please supply a crd file")
		os.Exit(1)
	}
	currentDir := os.Getenv("PWD")
	createDir(*outputDir)
	crdData, err := readApplication(fmt.Sprintf("%s/%s", currentDir, *crdFile))
	if err != nil {
		fmt.Errorf("error getting crdData: %v", err)
	}
	processCrds(crdData, *outputDir)
	// for _, crd := range crdData {
	// 	if crd.Kind == "Application" {
	// 		manifest, err := buildHelmCommand(crd)
	// 		if err != nil {
	// 			fmt.Println(err)
	// 		}
	// 		location := fmt.Sprintf("%s/%s", *outputDir, crd.Name)
	// 		fmt.Println(writeToFile(manifest, location))
	// 	}
	// }
}
